---
chapter: 4
knit: "bookdown::render_book"
---

```{r setup_04_chap, include=FALSE}
knitr::opts_chunk$set(
  fig.align = "center",
  echo = TRUE, 
  message = FALSE,
  warning = FALSE,
  error = FALSE,
  collapse = TRUE,
  comment = "",
  cache = FALSE, 
  cache.lazy = FALSE
)

library(spinifex)
library(ggplot2)
set.seed(1)

## FUNCTION FOR STATIC OUTPPUT
array2static <- function(.m_tour, .data, .m_var, .cat, .mag =2.2)
{
  slides       <- array2df(array = .m_tour, data = .data)
  basis_slides <- slides$basis_slides
  data_slides  <- slides$data_slides
  n_slides     <- max(basis_slides$slide)
  if (n_slides != 15) 
    stop(paste0("stop: n_slides !=15 !!!!! n_slides = ", n_slides))
  
  # Initialize
  ## manip var asethetics
  p             <- nrow(basis_slides) / n_slides
  col_v         <- rep("grey80", p)
  col_v[.m_var] <- "blue"
  col_v         <- rep(col_v, n_slides)
  siz_v         <- rep(0.3, p)
  siz_v[.m_var] <- 1
  siz_v         <- rep(siz_v, n_slides)
  cat           <- rep(as.factor(.cat), n_slides)

  ## circle
  angle <- seq(0, 2 * pi, length = 180)
  circ  <- data.frame(c_x = cos(angle), c_y = sin(angle))
  circ[nrow(circ)+1, ] <- NA
  ## data asethetics
  data_slides <- data.frame(data_slides, cat = rep(.cat, n_slides))
  
  grid_b <- grid_t <-
    data.frame(slide = 1:n_slides, 
               x = .mag*rep(1:5, 3), y = .mag*rep(3:1, each = 5))
  grid_t$y <- grid_t$y + max(grid_t$y)
  # OUTER JOIN
  basis_grid <- merge(x = basis_slides, y = grid_t, by = "slide", all = TRUE)
  # CROSS JOIN
  circ_grid  <- merge(x = circ, y = grid_t, by = NULL)
  # OUTER JOIN
  data_grid  <- merge(x = data_slides, y = grid_b, by = "slide", all = TRUE)
  
  # BASIS
  gg1 <-
    ggplot(data = basis_grid) +
    # AXES LINE SEGMETNS
    geom_segment(aes(x = V1 + x, y = V2 + y, xend = x, yend = y),
                 color = col_v, size = siz_v) +
    # AXES TEXT LABELS
    geom_text(aes(x = V1 + x, y = V2 + y, label = lab_abbr),
              color = col_v, vjust = "outward", hjust = "outward") +
    # AXES FRAME NUM
    geom_text(aes(x = x - .7, y = y + 1.1, 
                  label = paste0("frame: ",slide)), color = "grey50") +
    # AXES CIRCLE PATH
    suppressWarnings( # Suppress for "Removed 1 rows containing missing values."
      geom_path(data = circ_grid, color = "grey80",
                mapping = aes(x = x+c_x, y = y+c_y))
    )
  
  # PROJECTION
  gg2 <- gg1 +
    # PROJ DATA POINTS
    geom_point(data = data_grid, size = .7,
               mapping = aes(x = V1 + x, y = V2 + y, color = cat),
               shape = as.integer(cat) + 15) +
    # PROJ DATA FRAME NUM
    geom_text(data = data_grid, color = "grey50",
              mapping = aes(x = x - .7, y = y + 1.1, 
                            label = paste0("frame: ",slide))) +
    theme_void() +
    scale_color_brewer(palette = "Dark2") + 
    # coord_fixed() +
    theme(legend.position="none",
          panel.border = element_rect(colour = "black", fill = NA))
  
  gg2
}
```

# Work in progress {#ch:workinprogress}

Implementing UCS in low dimensions is fundamental to the extension of the UCS into 3D space. The implementation of such forms the foundation for future work addressed in the remaining research objectives. 

## RO #1) How can UCS be implemented in 1- and 2D projections?

This section covers the work done in the last year implementing USC via *manual tours*. Following experimental design methodology, this work implements the manual tour as described in @cook_manual_1997 and allows users to rotate a selected variable into and out of a 2D projection of high-dimensional space for user-controlled steering (UCS). The primary use is to determine the sensitivity of the structure to the contributions of the manipulation variable. This is particularly powerful for exploring the local structure once a feature of interest has been identified by a guided tour [@cook_grand_1995] for example. The algorithm for a manual tour allows rotations in horizontal, vertical, oblique, angular and radial directions. In the algorithm below focuses on radial rotation.

Section \ref{sec:algorithm} explains the algorithm using a toy dataset. A wider discussion of implementation as an *R* package and application to high energy physics data [@wang_visualizing_2018; @cook_dynamical_2018] is attached in appendix \ref{ch:spinifex_paper} formatted as a paper that will be submitted to The R Journal.


## Algorithm {#sec:algorithm}

Creating a manual tour animation requires these steps:

1. Provided with a 2D projection, choose a variable to explore. This is called the "manip" variable.
2. Create a 3D manipulation space, where the manip variable has a full contribution.
3. Generate a rotation sequence which zeros coefficient and increases it to 1 before returning to the initial position.

These steps are described in more detail below.

### Notation

Start with multivariate data in an $n \times p$ numeric matrix, and an orthonormal $d$-dimensional basis set is describing the projection from $p-$ to $d-$space.

\begin{align*}
  \textbf{X}_{[n,~p]} ~=
  \begin{bmatrix}
    X_{1,~1} & \dots  & X_{1,~p} \\
    X_{2,~1} & \dots  & X_{2,~p} \\
    \vdots   & \ddots & \vdots   \\
    X_{n,~1} & \dots  & X_{n,~p}
  \end{bmatrix}
\end{align*}

\begin{align*}
  \textbf{B}_{[p,~d]} ~=
  \begin{bmatrix}
    B_{1,~1} & \dots  & B_{1,~d} \\
    B_{2,~1} & \dots  & B_{2,~d} \\
    \vdots   & \ddots & \vdots   \\
    B_{p,~1} & \dots  & B_{p,~d}
  \end{bmatrix}
\end{align*}

The algorithm is primarily operating on the projection basis and utilizes the data only when making a display for computational efficiency. A more comprehensive list of tour notation is given in \ref{sec:tour_notation}.

### Toy data set

The flea data from @lubischew_use_1962 will be used as an example dataset. The data contains 74 observations across 6 variables, corresponding to physical measurements of the insects. Each observation belonging to one of three species.

A guided tour on the flea data is conducted by optimizing on the `holes` index [@cook_interactive_2007]. In a guided tour the projection sequence is selected by optimizing an index of interest in the projection. The `holes` index is maximized by when the projected data has a lack of observations in the center. Figure \@ref(fig:step0), shows an optimal projection of this data. The left plot displays the projection basis, while the right plot shows the projected data. The display of the basis has a unit circle with lines showing the horizontal and vertical contributions of each variable in the projection. Here is primarily `tars1` and `aede2` contrasting the other four variables. In the projected data there are three clusters, which have been colored, although not used in the optimization. The question that will be explored in the explanation of the algorithm is: how important is `aede2` to the separation of the clusters.

```{r step0, echo=F, results='hide', out.width='98%', fig.cap = "Basis reference frame (left) and projected data (right) of standardized flea data. Basis identified by holes-index guided tour. The variables `aede2` and `tars1` contribute mostly in the X direction, whereas the other variables contribute mostly in the Y direction. Select `aede2` as the manipulation variable to see how the structure of the projection changes."}
## Flea holes tour
f_dat  <- tourr::rescale(flea[,1:6])
f_cat  <- factor(flea$species)
f_path <- save_history(f_dat, guided_tour(holes()))
f_bas  <- matrix(f_path[,, max(dim(f_path)[3])], ncol=2)
f_mvar <- 5
f_msp  <- create_manip_space(basis = f_bas, manip_var = f_mvar)
f_proj <- data.frame(tourr::rescale(f_dat %*% f_msp[, 1:2]))

# step0, output
# Adjust centering to make axes and data side by side
view_basis(f_bas, labels = colnames(f_dat)) +
  geom_point(data = f_proj,
             mapping = aes(x = X1 + .75, y = X2 - .5, color = f_cat),
             pch = as.integer(f_cat) + 15) +
  theme(panel.border = element_rect(colour = "black", fill = NA))
```

The left frame of figure \@ref(fig:step0) shows the reference frame for the basis. It describes the X and Y contributions of the basis as it projects from the 6 variable dimensions down to 2. The right side shows how the data looks projected through this basis. You can project a single basis at any time through the matrix multiplication $\textbf{X}_{[n,~p]} ~*~ \textbf{B}_{[p,~d]} ~=~ \textbf{P}_{[n,~d]}$ to such effect.


### Step 1 Choose variable of interest

Select a manipulation variable, $k$. Initialize a zero vector $e$ and set the $k$-th element set to 1.

\begin{align*}
\textbf{e}_{[p,~1]} ~=~
  \begin{bmatrix}
    0 \\
    0 \\
    \vdots \\
    1 \\
    \vdots \\
    0
  \end{bmatrix}
\end{align*}

In figure \@ref(fig:step0), above, notice that the variables `tars1` and `aede2` are almost orthogonal to the other 4 variables and control almost all of the variation in the x-axis of the projection. `Aede2` has a larger contribution and is select it as the manip variable.


### Step 2 Create the manip space

Use the Gram-Schmidt process to orthonormalize the concatenation of the basis and $e$ yielding the manip space.

\begin{align*}
  \textbf{M}_{[p,~d+1]}
  &= Orthonormalize_{GS}( \textbf{B}_{[p,~d]}|\textbf{e}_{[p,~1]} ) \\
  &= Orthonormalize_{GS}
  \left(
    \begin{bmatrix}
      B_{1,~1} & \dots  & B_{1,~d} \\
      B_{2,~1} & \dots  & B_{2,~d} \\
      \vdots   & \ddots & \vdots   \\
      B_{k,~1} & \dots  & B_{k,~d} \\
      \vdots   & \ddots & \vdots   \\
      B_{p,~1} & \dots  & B_{p,~d}
    \end{bmatrix}
  ~|~
    \begin{bmatrix}
      0 \\
      0 \\
      \vdots \\
      1 \\
      \vdots \\
      0
    \end{bmatrix}
  \right)
\end{align*}


Adding an extra dimension to our basis plane allows for the manipulation of the specified variable. Orthonormalizing rescales the new vector while leaving the first $d$ variables identical to the basis. An illustration of such can be seen below in figure \@ref(fig:step2).

```{r step2, echo=F, out.width='100%', fig.cap = "Manipulation space for controlling the contribution of aede2 of standardized flea data. Basis was identified by holes-index guided tour. The out of plane axis, in red, shows how the manipulation variable can be rotated, while other dimensions stay embedded within the basis plane."}
#=== Step 2 output
view_manip_space(basis = f_bas, manip_var = f_mvar, labels = colnames(f_dat)) +
    theme(panel.border = element_rect(colour = "black", fill = NA))
```

Imagine being able to grab hold of the red axis and rotate it changing the projection onto the basis plane. This is what happens in a manual tour. For a radial tour, fix $\theta$, the angle within the blue plane, and vary the $\phi$, the angle orthogonal to the blue projection plane. The user controlling these angles changes the values of the coefficient the manip variable and performs a constrained rotation on the remaining variables.


### Step 3 Generate rotation

Define a set of values for $\phi_i$, the angle of out of the plane rotation, orthogonal to the projection plane. This corresponds to the angle between the red manipulation axis and the blue plane in figure \@ref(fig:step2).

**For ** $i$ **in 1 to n_slides:**

For each $\phi_i$, post multiply the manipulation space by a rotation matrix, producing, **RM**, the rotated manip space.

\begin{align*}
  \textbf{RM}_{[p,~d+1,~i]}
  &= \textbf{M}_{[p,~d+1]} ~*~ \textbf{R}_{[d+1,~d+1]}
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\text{For the $d=2$ case:} \\
  &= \begin{bmatrix}
    M_{1,~1} & \dots & M_{1,~d} & M_{1,~d+1} \\
    M_{2,~1} & \dots & M_{2,~d} & M_{2,~d+1} \\
    \vdots   & \ddots& \vdots   \\
    M_{p,~1} & \dots & M_{p,~d} & M_{p,~d+1}
  \end{bmatrix}_{[p,~d+1]}
    ~*~
  \begin{bmatrix}
    c_\theta^2 c_\phi s_\theta^2 &
    -c_\theta s_\theta (1 - c_\phi) &
    -c_\theta s_\phi \\
    -c_\theta s_\theta (1 - c_\phi) &
    s_\theta^2 c_\phi + c_\theta^2 &
    -s_\theta s_\phi \\
    c_\theta s_\phi &
    s_\theta s_\phi &
    c_\phi
  \end{bmatrix}_{[3,~3]}
\end{align*}

Where:
\begin{description}
  \item[$\theta$] is the angle that lies on the projection plane, the *XY*-scatterplot
  \item[$\phi$] is the angle orthogonal to the projection plane, in the *Z* direction relative to the *XY*-scatterplot
  \item[$c_\theta$] is the cosine of $\theta$
  \item[$c_\phi$]   is the cosine of $\phi$
  \item[$s_\theta$] is the sine of   $\theta$
  \item[$s_\phi$]   is the sine of   $\phi$
\end{description}

In application: compile the sequence of $\phi_i$ and create an array for each rotated manipulation space. $\phi$ is the angle of change relative to the $\phi_1$, the transformation $\phi_i$ - $\phi_1$ to useful to think about $\phi$ relative to the basis plane. If the manip variable doesn't move as expected this is the first place to check.


Figure \@ref(fig:step3) illustrates the sequence with 15 projected bases and highlight the manip variable on top, while showing the corresponding projected data points on the bottom. A dynamic version of this tour can be viewed online at https://nspyrison.netlify.com/thesis/flea_manualtour_mvar5/, (may take a moment to load).


(ref:step3-cap) Rotated manipulation spaces, a radial manual tour manipulating `aded2` of standardized flea data. The manipulation variable, `aede2`, extends from its initial contribution to a full contribution to the projection before decreasing to zero, and then returning to its initial state. A dynamic version can be viewed at https://nspyrison.netlify.com/thesis/flea_manualtour_mvar5/.

```{r step3, echo=F, warning=F, fig.height=7.2, fig.width=6, out.height='7.2in', out.width='6in', fig.cap = "(ref:step3-cap)"}
f_angle <- .26
f_mtour <- manual_tour(f_bas, manip_var = f_mvar, angle = f_angle)
if(dim(f_mtour)[3] != 15) message(
  paste0("!!!!! step3 n_slides != 15 !!!!! n_slides = ", dim(f_mtour)[3]))

#play_manual_tour(f_dat, f_bas, f_mvar, cat_var = f_cat, angle = f_angle)
array2static(.m_tour = f_mtour, .data = f_dat, .m_var = f_mvar, .cat = f_cat)
```


## Display projection sequence

To get back to data-space pre-multiply the rotated manip space by the data for the projection in data-space.

\begin{align}
  \textbf{P}_{[n,~d+1]}
    &= \textbf{X}_{[n,~p]} ~*~ \textbf{RM}_{[p,~d+1]} \\
    &=
      \begin{bmatrix}
          X_{1,~1} & \dots & X_{1,~p} \\
          X_{2,~1} & \dots & X_{2,~p} \\
          \vdots   & \vdots & \vdots  \\
          X_{n,~1} & \dots & X_{n,~p}
      \end{bmatrix}_{[n,~p]}
      ~*~
      \begin{bmatrix}
        RM_{1,~1} & RM_{1,~2} & RM_{1,~3} \\
        RM_{2,~1} & RM_{2,~2} & RM_{2,~3} \\
        \vdots    & \vdots    & \vdots    \\
        RM_{p,~1} & RM_{p,~2} & RM_{p,~3}
      \end{bmatrix}_{[p,~d+1]}
\end{align}

Plot the first $d$ variables from each projection in sequence for an $XY$-scatterplot. The remaining variable is sometimes linked to a data point aesthetic to produce depth cues used in conjunction with the $XY$-scatterplot. 

### Storage and sharing

Storing each data point for every frame with the overhead dynamic graphics is very inefficient. In the same way that efficiency is gain by performing math on the bases, the same approach suggested for storage and sharing tours. Consider a radial manual tour, the salient features can be stored in 3 bases, where $\phi$ is at its starting, minimum, and maximum values. The frames in between can be interpolated later by supplying angular speed.

