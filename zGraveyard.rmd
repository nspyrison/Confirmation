---
title: "Writing graveyard"
author: "Nicholas Spyrison"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 2019_01_21 from 03-spinifex

### rambling about tours in the introduction

Both classical and contemporary visualizations of data are presented in $d=2$ dimensions, that of a computer monitor or in print. How is it that we come to view and share data that exists in $p > 3$ dimensions? In an appeal to brevity we shall ignore model and parameter summarization due to there shortcomings [@anscombe_graphs_1973; @matejka_same_2017]. Within the realm of data-space visualization we are left with projecting higher volumes and embedding them within lower dimensional spaces that we can visualize.

This is not a new phenomena, such linear projections have been in use for quite some time. [@pearson_liii._1901; @fisher_use_1936] and the myriad of single value decomposition (SVD) techniques from numerous disciplines use such embeddings. Previous application look at data in one (or few) static orientations, after some objective optimization. For instance in PCA, we reorient $p$-dimensions such that we have a reference to the ordered components that describe a descending amount of variation held within the data. Yet we still have $p$ components remaining to visualize. Where does the dimension reduction come in? From plotting only the first two or three and potentially another dimension tied to data point aesthetic. This is maximizes the amount of variation that can be display in an embedding, but regularly discards a large proportion of the variation held within the data.

More recently non-linear dimensionality techniques have become popular, such as t-distributed stochastic neighbor embedding (t-SNE) [@maaten_visualizing_2008], building off of Sammon mappings [@sammon_nonlinear_1969]. Such non-linear methods make for astounding distinction when in lower embeddings, but contain inherent shortcomings. Namely: that the non-linear transformations break inter-operability back to the original data-space, and that they can suffer from overfitting. If there is no inherent clustering with the data, it's possible that noise within the variables may become the prominent feature and be displayed erroneously as group clustering.

TODO: Clean up touring, , below

[@asimov_grand_1985; @buja_grand_1986] first suggested grand tours in which random walks in $p$-space can be interpolated and embedded in $d$ dimensions which are then viewed in sequence. Imagine. Consider, 


The broader scope of touring has some beneficial features, namely: touring keeps the original dimensionality in tact unlike tradition static linear-projections, and maintains inter-operability back to the original dimensions, a primary drawback of non-linear dimensionality reduction.

TODO: clean up above, talk about touring in general first

### Terminology and demystifying projection:
TODO: clean up the terminology section
basis, data, n, p, d,

Suppose that we have tri-variate data, $\textbf{X}_{[8,~3]}$, the corners points of a rectanguloid. We can describe the relative orientation by defining

For every $p$-dimensional space can be described by the direction and magnitude of axes in a square matrix that we call a basis. Imgine 3 axes of an XYZ Caresian volume (*ie.* a basis $\in \mathbb{R}^p$). In matimatical form we would write this as a diagonal identity matrix of demension 3.

```{r}
# b <- diag(3)
# xyz <- c("X", "Y", "Z")
# rownames(b) <- xyz
# colnames(b) <- xyz
# b
```

This basis has some nice properties that are mathimatically nice to preserve, namely, that each axis as is at a right angle to the other (*orthagonal*), and are unit *normal* (length or norm equal to one). If matrix meets both of these criteria we call it *orthonormal*.

```{r}
# set.seed(15)
# library(plotly)
# library(processx)
# X = 9*runif(100) # X = 9*c(0,1,1,0,0,1,1,0)
# Y = 6*runif(100) # Y = 6*c(0,0,1,1,0,0,1,1)
# Z = 2*runif(100) # Z = 2*c(0,0,0,0,1,1,1,1)
#
# p <- plot_ly(x=X, y=Y, z=Z, type="scatter3d", mode="markers")
# ###STATIC OUTPUT REQURIES ORCA SETUP, NOT TRANsFERABLE...
# # orca(p, "cube_demo.png") # but, needs orca setup,
# # plotly_IMAGE(p, format = "png", out_file = "output.png")
```

### Illustrating flea and breast cancer

Let:
\begin{description}
  \item[$d=2$] For illustration's sake, we'll embed into 2 dimensions.
\end{description}

Given:
\begin{description}
  \item[$\bf{X}_{[74,~6]}$] Flea data, 74 observations by 6 variables, $\bf{X} \in \mathbb{R}^6, ~p=6$.
  \item[$p=6$]
\end{description}

Let's initialize a random orthonormal basis of dimensions [$p,~d$], which describes a random orientation projected from 6 down to 2 dimensions. Check how each of the dimensions is contributing the XY components with `view_basis()`

TODO: reference fig 1, keep in mind that the figure floats more than the table.
TODO: consider adding a `view_manip_sp()` function with phi and theata, etc.

```{r, fig.cap = "Random basis, flea data"}
library(spinifex)

flea_std <- rescale(flea[, 1:6])
rb <- basis_random(ncol(flea_std), 2)
view_basis(basis = rb, labels = colnames(flea_std)) 
```

Perform a manual tour on the random basis with `manual_tour()`, We'll arbitratrily choose the 4th variable, aede1, and let the default selection of `phi` go from it's start, to 0 radians, to pi/2 radians, and back to the start position. In turn the norm of manipualtion variable goes to 1 and then 0, before returning to it's inital position. 

```{r, fig.cap = "Manual tour, flea data", echo = TRUE, eval=FALSE}
mtour <- manual_tour(basis = rb, manip_var = 4)
mslides <- create_slides(tour = mtour, data = flea_std)

render_plotly(mslides)
```
 TODO: write follow up and segway into breast cancer; play_tour (holes), explore local area. 
 TODO: note that render_plotly didn't add the figure caption.


## 2019_01_28 from chap3 spinifex atb at making function to clean code.

THIS IS SLIGHTLY OUT DATED GOING TO WEBSITE TO PULL.
```{r}
library(spinifex)
load("./data/jetsProj_sub.rda") # fig 7, subset of ATLAS7old and ATLAS7new
load("./data/PDFSense_fig7_basis.rda") # fi 7
load("./data/grDIScenter.rda") # fig 8, left
load("./data/grDISsphere.rda") # fig 8, right
load("./data/PDFSense_fig8l_basis.rda") # fig 8, left
# load("./data/PDFSense_fig8r_basis.rda") # fig 8, right

# Fig 7, subset of ATLAS7old and ATLAS7new
view_basis(fig7_basis)
play_manual_tour(data = jetsProj_sub[, 1:4], basis = fig7_basis, manip_var = 3,
                 cat_var = jetsProj_sub$exp)
play_manual_tour(data = jetsProj_sub[, 1:4], basis = fig7_basis, manip_var = 4,
                 cat_var = jetsProj_sub$exp)

# Fig 8,
view_basis(fig8l_basis)
play_manual_tour(data = grDIScenter[, 1:6], basis = fig8l_basis, manip_var = 6,
                 cat_var = grDIScenter$disID)
play_manual_tour(data = grDIScenter[, 1:6], basis = fig8l_basis, manip_var = 5,
                 cat_var = grDIScenter$disID)
```

## 2019_01_28 from chap 3 trouble shooting manual_tour

outdated:
```{r, eval=F,include=F}
#TODO: TORUBLESHOOT HERE;; EVAL=F,INCLUDE=F
b1 <- basis_slides[basis_slides$slide==1,1:2]
m1 <- mtour[,,1] #m tour, from h_bas,

view_basis(h_bas) #TARGET
view_basis(b1) # WRONG, BACK UP
view_basis(m1) # WRONG;
print("wrong before b1 at m1; meaning issue in manual_tour, which seemed to work for example...")

# REPRODUCE FROM EXAMPEL:
DAT <- tourr::rescale(tourr::flea[,1:6])
BAS <- tourr::basis_random(n = ncol(DAT))
MT  <- manual_tour(basis = BAS, manip_var = 5) # HOMOMORPHISM...
view_basis(BAS) #TARGET
view_basis(MT[,,1]) #WRONG; WORK BACK FROM MANUAL_tour
view_manip_space(BAS, 5) #GOOD
M_SP    <- create_manip_space(basis = BAS, manip_var = 5)
view_basis(M_SP[,1:2]) #GOOD
theta <- atan(BAS[m_var, 2] / BAS[m_var, 1])
P_ST      <- acos(sqrt(BAS[m_var, 1]^2 + BAS[m_var, 2]^2))
R_SP <- rotate_manip_space(manip_space = M_SP, theta = theta, phi = P_ST)[, 1:2]
view_basis(R_SP)
#INIT

phi_start_sign <- P_ST * sign(M_SP[m_var, 1]) 
phi_inc        <- pi / (n_sli - 3)
p              <- nrow(BAS)
d              <- ncol(BAS)
seq_start <- NULL; seq_end <- NULL
W1 <- interpolate_walk(P_ST,P_ST)
```

## 2019_01_29 from _firgures.r, initial code for spinifex, chap3


```{r}
rep(print("THIS WAS INITIAL DOCUMENT AND MAY BE STALE. CHAPTER CODE SHOULD BE TRUSTED OVER THIS."),3)

library(spinifex)
library(ggplot2)
library(gridExtra)
set.seed(1) #don't think this matters, but can't hurt.

# ## FLEA HOLES TOUR
# flea_std <- tourr::rescale(tourr::flea[,1:6])
# hpath    <- tourr::save_history(flea_std, tourr::guided_tour(tourr::holes))
# h_bas    <- matrix(hpath[,,max(dim(hpath)[3])], ncol=2)
#
# #0_left
# step0_l <- view_basis(h_bas) # Maybe manual tour on v1?
#
# h_m_sp <- create_manip_space(h_bas, manip_var = 1)
# h_dat  <- cbind(data.frame(flea_std %*% h_m_sp[, 1:2]), flea$species)
# colnames(h_dat) <- c("x", "y", "species")
#
# #0_right
# step0_r <- ggplot() +
#   geom_point(h_dat, mapping = aes(x=x, y=y, color=species)) +
#   scale_color_brewer(palette = "Dark2") +
#   theme_void() +
#   theme(legend.position=c(0.8, 0.8)) +
#   theme(legend.background = element_rect(colour = 'black', fill = 'grey90', linetype='solid'))
#
#
# #=== Step 0 out
# step0 <- grid.arrange(step0_l, step0_r, ncol=2)
# ggsave("./output/step0_basis+proj.png", step0,
#        height = 4, width = 4*1.61, units = "in")

#=== Step 2 out
step2 <- view_manip_sp(h_bas, 5)
ggsave("./output/step2_manip_sp.png", step2,
       width = 4, height = 4, units = "in")


#===
mtour <- manual_tour(h_bas, manip_var = 5, n_slides = 15)
bases <- create_slides(tour = mtour, data = flea_std)
bases <- bases$basis_slides

mag <- 2.2
grid  <- data.frame(slide = 1:15, x = mag*rep(1:5, 3), y = mag*rep(3:1, each = 5))

# Initialize
## manip var asethetics
n_slides         <- max(bases$slide)
p                <- nrow(bases) / n_slides
manip_var        <- 5
col_v            <- rep("grey80", p)
col_v[manip_var] <- "blue"
col_v            <- rep(col_v, n_slides)
siz_v            <- rep(0.3, p)
siz_v[manip_var] <- 1
siz_v            <- rep(siz_v, n_slides)
## circle
angle <- seq(0, 2 * pi, length = 180)
circ  <- data.frame(c_x = cos(angle), c_y = sin(angle))
circ[nrow(circ)+1, ] <- NA

bases_grid <- merge(x = bases, y = grid, by = "slide", all = TRUE) # OUTER JOIN
circ_grid <- merge(x = circ, y = grid, by = NULL) # CROSS JOIN,

#=== Step 3 out
(step3 <- ggplot(data = bases_grid) +
  geom_segment(aes(x = V1+x, y = V2+y, xend = x, yend = y),
               color = col_v, size = siz_v) +
  geom_text(aes(x = V1+x, y = V2+y, label = lab_abbr),
            color = col_v, vjust = "outward", hjust = "outward") +
  geom_path(data = circ_grid, mapping = aes(x = x+c_x, y = y+c_y), color = "grey80") +
  theme_void())
ggsave("./output/step3_manual_tour.png", step3, width = 4*(5/3), height = 4)


```

## 2019_01_xx from xx
