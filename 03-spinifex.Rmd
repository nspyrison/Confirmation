---
chapter: 3
knit: "bookdown::render_book"
---

# *spinifex*: extending *tourr* with manual tours and graphic display {#ch:spinifex}

## Abstract

Touring teqniques offer a great opertunity for data-space vizualization of ($p > 3$) multivariate data sets. This paper discusses the *R* package *spinifex*, which adds support for the manual tour, which is particularly usefuly for exploring the local structure after identifying a feature of interest, perhaps via guided tour. Additionally, *spinifex* extends graphic outputs to *plotly* and *gganimation*. This work extends the functionality of and is compatible with *tourr*.

Keywords: grand tour, projection pursuit, manual tour, tourr, touring, high dimenson visualization, hihg dim vis, dimensionality reduction, visualization, statistical graphics, data-space.


## Introduction

Both classical and contemorary visualizations of data are presented in two dimensions, that of a computer monitor or in print. How is it that we come to view and share data that exsists in $p > 3$ dimensions? In an appeal to brievity we shall ignore model and parameter summarization due to there shortcomings [@anscombe_graphs_1973; @matejka_same_2017]. Within the realm of data-space visualization we are left with projecting higher volumes and embedding them within lower dimensional spaces that we can vizualize.

This is not a new phenomena, such linear projections have been in use for quite some time. [@pearson_liii._1901; @fisher_use_1936] and the myriad of single value deconcomposistion (SVD) techniques from numerous disciplines use such embeddings. Previous application look at data in one (or few) static orientations, after some objective optimization. For instance in PCA, we reorient $p$-dimensions such that we have a reference to the ordered components that describe a descending ammount of variation held within the data. Yet we still have $p$ components remaining to visualize. Where does the dimension reduction come in? From plotting only the first two or three and potenially another dimension tied to data point asthetic. This is maximizes the ammount of variation that can be display in an emedding, but regually discards a large proportion of the variation held within the data.

More recently non-linear dimensionality techniques have become popular, such as t-distributed stchocastic neighbor embedding (t-SNE) [@maaten_visualizing_2008], building off of sammon mappings [@sammon_nonlinear_1969]. Such non-linear methods make for astounding distinction when in low $d$ embeddings, but contain inhearant shortcomings. Namely: that the non-linear tranformations break inter-operability back to the original data-space, and that they can suffer from overfitting. If there is no inherent clustering with the data, it's posible that noise within the variables may become the proment feature and be displayed erroneously as group clustering.

[@asimov_grand_1985; @buja_grand_1986] suggested grand tours in which random walks in $p$-space can be interpolated and embedded in $d$ dimensions which are then viewed in sequence. The broader scope of touring has some beneficial features, namely: touring keeps the original dimensionality in tact unlike tradition static linear-projections, and maintains inter-operabilty in the orginal dimensions, a primary drawback of non-linear dimensionality reduction.

TODO: clean up above, talk about what 

## Terminology and demystifying projection:

TODO: clean up the terminology section

basis, data, n, p, d, 

Suppose that we have tri-variate data, $\textbf{X}_{[8,~3]}$, the corners points of a rectanguloid. We can describe the relative orientation by defining 

For every $p$-dimensional space can be described by the direction and magnitude of axes in a square matrix that we call a basis. Imgine 3 axes of an XYZ Caresian volume (*ie.* a basis $\in \mathbb{R}^p$). In matimatical form we would write this as a diagonal identity matrix of demension 3.

```{r}
# b <- diag(3)
# xyz <- c("X", "Y", "Z")
# rownames(b) <- xyz
# colnames(b) <- xyz
# b
```

This basis has some nice properties that are mathimatically nice to preserve, namely, that each axis as is at a right angle to the other (*orthagonal*), and are unit *normal* (length or norm equal to one). If matrix meets both of these criteria we call it *orthonormal*.

```{r}
# set.seed(15)
# library(plotly)
# library(processx)
# X = 9*runif(100) # X = 9*c(0,1,1,0,0,1,1,0)
# Y = 6*runif(100) # Y = 6*c(0,0,1,1,0,0,1,1)
# Z = 2*runif(100) # Z = 2*c(0,0,0,0,1,1,1,1)
# 
# p <- plot_ly(x=X, y=Y, z=Z, type="scatter3d", mode="markers")
# ###STATIC OUTPUT REQURIES ORCA SETUP, NOT TRANsFERABLE...
# # orca(p, "cube_demo.png") # but, needs orca setup, 
# # plotly_IMAGE(p, format = "png", out_file = "output.png")
```


## Manual tour

Let's explore the process behind the manual tour

Given:
\begin{description}
  \item[$\textbf{X}_{[n,~p]}$] A dataset contaning $n$ observations of $p$ numeric variables. 
  \item[$\textbf{B}_{[p,~d]}$] An orthonormal \footnote{Where each variable is both: orthagonal, at right angles (dot product is 0) to the other variabels, and unit vectors, a norm = 1} basis describing the current orientation projecting $p$ down to $d$ dimension.
\end{description}

\begin{align*}
  \textbf{X}_{[n,~p]} ~=
  \begin{bmatrix}
    X_{1,~1} & \dots  & X_{1,~p} \\
    X_{2,~1} & \dots  & X_{2,~p} \\
    \vdots   & \ddots & \vdots   \\
    X_{n,~1} & \dots  & X_{n,~p}
  \end{bmatrix}
\end{align*}

\begin{align*}
  \textbf{B}_{[p,~d]} ~=
  \begin{bmatrix}
    B_{1,~1} & \dots  & B_{1,~d} \\
    B_{2,~1} & \dots  & B_{2,~d} \\
    \vdots   & \ddots & \vdots   \\
    B_{p,~1} & \dots  & B_{p,~d}
  \end{bmatrix}
\end{align*}

<!-- Let: -->
<!-- \begin{description} -->
<!--   \item[$d=2$] For the sake of illustration. -->
<!-- \end{description} -->
TODO: move this down to a usage example.

For ease of computation we will be wroking mostly with the basis and not the data, once basis manipulation is done postmultiply the data by the basis to get back to data-space.  

Select a manipulation variable, $k$. Initialize a zero vector $e$, and set the $k$-th element set to 1. Use the Gram-Schmidt process to orthornormalize the concatenation of the basis and $e$ yielding the manipulation space.

\begin{align*}
  \textbf{M}_{[p,~d+1]}
  &= Orthnormalize_{GS}( \textbf{B}_{[p,~d]}|\textbf{e}_{k~[p,~1]} ) \\
  &= Orthnormalize_{GS}
  \left(
    \begin{bmatrix}
      B_{1,~1} & \dots  & B_{1,~d} \\
      B_{2,~1} & \dots  & B_{2,~d} \\
      \vdots   & \ddots & \vdots   \\
      B_{k,~1} & \dots  & B_{k,~d} \\
      \vdots   & \ddots & \vdots   \\
      B_{p,~1} & \dots  & B_{p,~d}
    \end{bmatrix}
  ~|~
    \begin{bmatrix}
      0 \\
      0 \\
      \vdots \\
      1 \\
      \vdots \\
      0
    \end{bmatrix}
  \right)
\end{align*}

TODO: clean up the langue of phi, tie to manip var.

Select a vector $\phi_i$, the angle of out-of plane rotation, orthagonal to the projection plane (relative to $\phi_1$, the transformation $\phi_i$ - $\phi_1$ proved to be helpful to discuss $\phi$ relative to the Z axis). 

**For ** $i$ **in 1 to n_slides:**
<!-- Don't fix the above, it's not going to happen... -->

For each $\phi_i$, postmultiply the manipulation space by a rotation matrix,  producing as many basis-projections.

\begin{align*}
  \textbf{P}_{b[p,~d+1,~i]}
  &= \textbf{M}_{[p,~d+1]} ~*~ \textbf{R}_{[d+1,~d+1]} \\
  &= \begin{bmatrix}
    M_{1,~1} & M_{1,~2} & M_{1,~3} \\
    M_{2,~1} & M_{2,~2} & M_{2,~3} \\
    \vdots   & \vdots   & \vdots   \\
    M_{p,~1} & M_{p,~2} & M_{p,~3}
  \end{bmatrix}_{[p,~d+1]}
    ~*~
  \begin{bmatrix}
    c_\theta^2 c_\phi s_\theta^2 &
    -c_\theta s_\theta (1 - c_\phi) &
    -c_\theta s_\phi \\
    -c_\theta s_\theta (1 - c_\phi) &
    s_\theta^2 c_\phi + c_\theta^2 &
    -s_\theta s_\phi \\
    c_\theta s_\phi &
    s_\theta s_\phi &
    c_\phi
  \end{bmatrix}_{[3,~3]}
\end{align*}
For the $d=2$ case.

Where:
\begin{description}
  \item[$\theta$] is the angle that lies on the projection plane ($ie.$ on the XY plane)
  \item[$\phi$] is the angle orthagonal to the projection plane ($ie.$ in the Z direction)
  \item[$c_\theta$] is the cosine of $\theta$
  \item[$c_\phi$]   is the cosine of $\phi$
  \item[$s_\theta$] is the sine of   $\theta$
  \item[$s_\phi$]   is the sine of   $\phi$
\end{description}

To get back to data-space post multply each projection basis by the data, for  the data projection.

\begin{align}
  \textbf{P}_{d[n,~d+1]}
    &= \textbf{X}_{[n,~p]} ~*~ \textbf{P}_{b[p,~d+1]} \\
    &= \begin{bmatrix}
      X_{1,~1} & \dots & X_{1,~p} \\
      X_{2,~1} & \dots & X_{2,~p} \\
      \vdots   & \vdots & \vdots  \\
      X_{n,~1} & \dots & X_{n,~p}
    \end{bmatrix}_{[n,~p]}
      ~*~
    \begin{bmatrix}
      P_{b:1,~1} & P_{b:1,~2} & P_{b:1,~3} \\
      P_{b:2,~1} & P_{b:2,~2} & P_{b:2,~3} \\
      \vdots     & \vdots     & \vdots     \\
      P_{b:p,~1} & P_{b:p,~2} & P_{b:p,~3}
    \end{bmatrix}_{b[p,~d+1]}
\end{align}

Plot the first two variables from each projection in sequence for an XY scatterplot. The remaining variable is sometimes linked to a data point asethetic to produce depth cues used in conjunction with the XY scatterplot.


## Usage

### Flea

Let's start off with the flea dataset from the R package *tourr* [@wickham_tourr_2011], which offers other tours of the flea dataset. The flea data contains 74 observations of flea bettles across 6-physical mesurement variables. Each observation belongs to one of three spieces being observered.

The data exisits in $p=6$ dimensions, for ease of illustration let $d=2$ we need a basis, describing the projection from 6 down to 2 dimensions. Let's find an initial basis to work with doing a guided tour from the *tourr*, using pca as the index, stochastic gradent descent optimizing the variation explained in the two dimensional embedding. Let's see

```{r}
library(spinifex)
library(tourr)

flea_std <- tourr::rescale(flea[, 1:6])
tpath <- tourr::save_history(flea_std, tourr::guided_tour(tourr::cmass))
play_tour(tour = tpath, data = flea_std)
```

We'll select the the third variable, *head*, currently not contributing to the projection to manually 

```{r}
mtour <- manual_tour(ib, manip_var = 3)
create_slides(tour = mtour, data = flea_std)
```




### Breast Cancer

Let's apply a manual tour to the Wisconsin Breast Cancer Database, formated from the machine learning benchmarking data sets in the *R* package [@leisch_mlbench:_2010].

```{r}
library(spinifex)
library(tourr)
str(spinifex::breastcancer)

bc_std <- tourr::rescale(breastcancer[,2:9])
ib <- tourr::basis_init(n = ncol(bc_std), 2)
view_basis(ib)
```
  TODO: PDF output is a static image w/ play slider.